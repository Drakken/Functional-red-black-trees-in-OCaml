
This is a module for using red-black trees in OCaml. It can be used to 
store simple elements that can be compared with (<), (=), and (>), or 
for more complicated types in real-world applications. 

The insert and delete functions in this module use a functional version 
of the conventional rebalancing system, which searches for useful nodes 
near a node that has just been inserted or deleted. This goes against 
conventional wisdom in functional programming*, which seems to be based
in part on the idea that, after a node is deleted, the need for the 
affected subtree to be rebalanced has to be encoded in the tree itself 
with a special color. 

This module takes a slightly different approach: After a node is deleted, 
the delete function passes the color of the deleted node to the rebal-
ancing function along with the affected subtree. If the color is red, 
the rebalancing function returns immediately. If the deleted node was 
black, each call to the function returns black until one call finds a 
subtree that can be rebalanced, and then the remaining calls return red.


User's guide

  type 'a t: the type of red-black trees

  empty: an empty tree

  insert e t: add an element to a tree and return the new tree
  insert_new e t: don't insert if the element is already in the tree

  remove e t: remove one node containing the element and return the new tree
  remove_all e t: remove all nodes containing the element

  size t: the number of nodes in a tree

  is_member e t: whether an element is in a tree

  of_list l: create a tree from a list
  to_list t: create a list from a tree

  merge t1 t2: all the nodes in the two trees, together in one tree
  union t1 t2: merge with no duplication (uses insert_new instead of insert)
               Duplicates are eliminated from the smaller of the two trees
               (based on black height), but not from the larger one.

  fold_left  f acc t: in-order fold
  fold_right f acc t: reverse in-order fold

  map  f t: map for trees
  mapi f t: map with in-order numbering of nodes

  iter  f t: in-order iteration
  iteri f t: iter with in-order numbering

  Make (E): a functor to create modules for complex elements

In modules generated by Make, is_member and the removal functions take a key
instead of an element. Those modules have concrete types, along with two 
additional functions:

  type element = E.t

  type t = element RedBlackTree.t

  find  k t: returns an optional element from the tree with the specified key
  value k t: calls find and extracts the value from the element

User-defined modules don't have map or mapi, but you can use the ones in 
RedBlackTree.

To create a module with Make, you'll need to write your own module describing 
the elements in the tree:
 
  Typeof_Element: the type of the element module passed to Make

Your module must contain these items:

    t: the type of the elements in the tree
    tkey: the type of element keys
    tval: the type of element values
    key e: returns an element's key
    value e: returns an element's value
    compare k1 k2: the comparison function. Returns zero for equal keys,
                   a negative integer when k1 belongs before k2, and
                   a positive integer when k1 belongs after k2.



* Chris Okasaki, Red-Black Trees in a Functional Setting, J. Functional Programming, January 1993
* https://www.cs.cornell.edu/courses/cs3110/2021sp/textbook/eff/rb.html
